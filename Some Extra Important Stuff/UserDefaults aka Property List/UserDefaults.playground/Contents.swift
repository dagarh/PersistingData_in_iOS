//: Playground - noun: a place where people can play

import UIKit

/*
 Because "UserDefaults" is a property list, an object that isn’t a property list type must be archived to a Data object in order to store it in UserDefaults.
 
 let ud = UserDefaults.standard
 let c = UIColor.blue
 let cdata = NSKeyedArchiver.archivedData(withRootObject:c)
 ud.set(cdata, forKey: "myColor")
 
 A Swift 4 PropertyListEncoder creates a Data object, so we can use it to store a Person object in UserDefaults:
 
 let ud = UserDefaults.standard
 let p = Person(firstName: "Matt", lastName: "Neuburg")
 let pdata = try! PropertyListEncoder().encode(p)
 ud.set(pdata, forKey: "person")
 
 The outcome is not substantially different from calling NSKeyedArchiver’s archivedData(withRootObject:), because the Data object generated by archivedData(withRootObject:) is itself a property list
 */


/* You try to access reference of this anywhere in your code, you would get same object every time. This is called as singleton pattern. "defaults" is just a reference to the property list in users Library directory. */
let defaults = UserDefaults.standard

/* Storing each and everything in single plist in never a good idea. Because even if you want to access just one property then whole plist would be loaded in memory. So that is not recommended. So using "UserDefaults" is never a good idea if you want to store large data. It is only for user's preferences. */

/* 'Userdefaults'[single plist] a.k.a 'Plist' supports only few types, not all types. You can see list of types supported by plist in an image which I saved. It also supports "Date" and "Data" format. So, if you want to store your custom types or array of any custom type then you can store them in Userdefaults(or plist)[even though it is not a good idea or practice to store custom types using UserDefaults but I am just showing you a hack which is possible], but before storing into Userdefaults plist we need to convert that custom type or any other type which is unknown to plist, to 'Data' object[because 'Data' is a type supported by plist] using either NSKeyedArchiver.archivedData(withRootObject:) or PropertyListEncoder().encode() methods. */

/* NSKeyedArchiver.archivedData(withRootObject:) and PropertyListEncoder().encode()  --> They in itself returns property list format in bytes form i.e in Data object form. */

/* You know what it is doing under the hood ??? --> it is serializing it in plist format + encoding that format to bytes form and then saving it at user's document directory. */
UserDefaults.standard.set([1,2,3], forKey: "array")

/* You know what it is doing under the hood ??? --> it is first reading the content of plist file in bytes format and then decoding it and then finally de-serializing that into swift "Array". */
UserDefaults.standard.array(forKey: "array")


/* This is how custom objects could be stored in UserDefaults plist file with the help of encoders and could be fethed back with the help of decoders but never do this way. This is very bad way of doing things. I am just showing you the hack. */
class Himanshu : Codable, Equatable {
    var name: String = "Himanshu"
    var age: Int = 24
    var weight: Double = 84.5
    var birthdayDate: Date = Date()
    
    var laptops : [Laptop] = [Laptop(color: "Purple")]
    
    static func == (lhs: Himanshu, rhs: Himanshu) -> Bool {
        return lhs.name == rhs.name && lhs.age == rhs.age && lhs.weight == rhs.weight && lhs.laptops == rhs.laptops
    }
}

class Laptop : Codable, Equatable {
    var color : String = "Red"
    init(color: String) {
        self.color = color
    }
    
    static func == (lhs: Laptop, rhs: Laptop) -> Bool {
        return lhs.color == rhs.color
    }
    
}

let userDefaults = UserDefaults.standard
var obj = Himanshu()
let data : Data = try! PropertyListEncoder().encode(obj)
userDefaults.set(data, forKey: "obj")

let savedData : Data = userDefaults.object(forKey: "obj") as! Data

/* This is the place where plist gets stored for the UserDefaults. */
print(FileManager.default.urls(for: .libraryDirectory, in: .userDomainMask).first!.appendingPathComponent("Preferences"))

let savedObj = try! PropertyListDecoder().decode(Himanshu.self, from: savedData)
data == savedData
obj == savedObj

/* Always remember that NSKeyedArchiver.archivedData(withRootObject:) can not be used for all object types to convert into "Data" data type i.e it form of bytes. Instead use Encoders like JSON Encoders and Property List Encoders. */

